{"data": [{"id": 0, "name": "En qu\u00e9 parte del ciclo de vida de una vista de SwiftUI ser\u00e1 apropiado actualizar un @StateObject?", "answers": [{"id": "type_a", "value": "onAppear"}, {"id": "type_b", "value": "init"}, {"id": "type_c", "value": "onChange"}, {"id": "type_d", "value": "onDisappear"}], "code": "struct ContentView: View {\n    @StateObject var model = MyModel()\n\n    var body: some View {\n        Text(\"Hello, World!\")\n            .onAppear(perform: {\n                // Actualizar el @StateObject aqu\u00ed\n            })\n    }\n}", "gistURL": "https://gist.github.com/SwiftBeta/4b141d10a86d2349bce28a5f05eb7ea3.js", "correct": "type_a", "explanation": "onAppear es el lugar adecuado para actualizar un @StateObject ya que es cuando la vista aparece en la pantalla.", "created_by": "SwiftBeta_"}, {"id": 1, "name": "C\u00f3mo se debe declarar una variable en Swift que no debe cambiar despu\u00e9s de su inicializaci\u00f3n?", "answers": [{"id": "type_a", "value": "var"}, {"id": "type_b", "value": "let"}, {"id": "type_c", "value": "const"}, {"id": "type_d", "value": "final"}], "code": "", "gistURL": "", "correct": "type_b", "explanation": "let se utiliza para declarar constantes en Swift, lo que significa que no se puede cambiar despu\u00e9s de su inicializaci\u00f3n.", "created_by": "SwiftBeta_"}, {"id": 2, "name": "Cu\u00e1l es el prop\u00f3sito de la palabra clave deinit en Swift?", "answers": [{"id": "type_a", "value": "Inicializar un objeto"}, {"id": "type_b", "value": "Actualizar un objeto"}, {"id": "type_c", "value": "Desinicializar un objeto"}, {"id": "type_d", "value": "Crear una subclase"}], "code": "class MyClass {\n    deinit {\n        // C\u00f3digo aqu\u00ed\n    }\n}", "gistURL": "https://gist.github.com/SwiftBeta/554abbf3bfae395314d94c5544aa003f.js", "correct": "type_c", "explanation": "deinit es un m\u00e9todo especial que se llama autom\u00e1ticamente cuando un objeto es desinicializado y liberado de la memoria.", "created_by": "SwiftBeta_"}, {"id": 3, "name": "Cu\u00e1l de las siguientes afirmaciones sobre los closures en Swift es verdadera?", "answers": [{"id": "type_a", "value": "Los closures no pueden capturar y almacenar referencias a variables y constantes"}, {"id": "type_b", "value": "Un closure puede tener siempre un nombre y una lista de par\u00e1metros"}, {"id": "type_c", "value": "Los closures pueden tener una sintaxis m\u00e1s ligera y optimizada para contextos inferidos"}, {"id": "type_d", "value": "Todos los closures deben usar el modificador @escaping"}], "code": "let myClosure: (Int, Int) -> Int = { a, b in\n    return a + b\n}", "gistURL": "https://gist.github.com/SwiftBeta/abac5811894a87b27be17468a50b9143.js", "correct": "type_c", "explanation": "Los closures pueden tener una sintaxis m\u00e1s ligera y optimizada en contextos inferidos, lo que los hace m\u00e1s legibles y concisos.", "created_by": "SwiftBeta_"}, {"id": 4, "name": "Qu\u00e9 m\u00e9todo se debe sobrescribir en una subclase para cambiar la configuraci\u00f3n de una UITableViewCell?", "answers": [{"id": "type_a", "value": "cellForRowAt"}, {"id": "type_b", "value": "prepareForReuse"}, {"id": "type_c", "value": "awakeFromNib"}, {"id": "type_d", "value": "configureCell"}], "code": "class CustomTableViewCell: UITableViewCell {\n    override func awakeFromNib() {\n        super.awakeFromNib()\n        // Configurar la celda aqu\u00ed\n    }\n}", "gistURL": "https://gist.github.com/SwiftBeta/1e293bb4d90e635f1fdf2e6aadee18d6.js", "correct": "type_c", "explanation": "El m\u00e9todo awakeFromNib se llama cuando la celda es cargada desde un archivo xib o storyboard y es el lugar adecuado para configurar la apariencia y el contenido de la celda.", "created_by": "SwiftBeta_"}, {"id": 5, "name": "Cu\u00e1l de las siguientes opciones es un ejemplo de property wrapper en SwiftUI?", "answers": [{"id": "type_a", "value": "@Binding"}, {"id": "type_b", "value": "@escaping"}, {"id": "type_c", "value": "@autoclosure"}, {"id": "type_d", "value": "@available"}], "code": "", "gistURL": "", "correct": "type_a", "explanation": "@Binding es un property wrapper en SwiftUI que crea un enlace mutable entre una propiedad y su fuente de datos, permitiendo que los cambios en la propiedad se propaguen a la fuente de datos.", "created_by": "SwiftBeta_"}, {"id": 6, "name": "Qu\u00e9 tipo de error se representa con la palabra clave try! en Swift?", "answers": [{"id": "type_a", "value": "Un error que debe manejarse"}, {"id": "type_b", "value": "Un error que puede ser ignorado"}, {"id": "type_c", "value": "Un error que se maneja autom\u00e1ticamente"}, {"id": "type_d", "value": "Un error que no debe ocurrir y causar\u00eda un crash si ocurre"}], "code": "let result = try! someThrowingFunction()", "gistURL": "https://gist.github.com/SwiftBeta/b37e693ed3b5aa71c56fc728db116b6b.js", "correct": "type_d", "explanation": "La palabra clave try! indica que un error no debe ocurrir y que si ocurre, causar\u00e1 un crash en tiempo de ejecuci\u00f3n.", "created_by": "SwiftBeta_"}, {"id": 7, "name": "Qu\u00e9 significa la palabra clave override en Swift?", "answers": [{"id": "type_a", "value": "Crea un m\u00e9todo en una subclase que es id\u00e9ntico al de la superclase"}, {"id": "type_b", "value": "Permite a una subclase proporcionar una implementaci\u00f3n personalizada de un m\u00e9todo de la superclase"}, {"id": "type_c", "value": "Declara un m\u00e9todo que puede ser sobrescrito por cualquier subclase"}, {"id": "type_d", "value": "Indica que un m\u00e9todo debe ser llamado en lugar del m\u00e9todo de la superclase"}], "code": "class MyBaseClass {\n    func myMethod() {}\n}\n\nclass MySubClass: MyBaseClass {\n    override func myMethod() {\n        // C\u00f3digo personalizado aqu\u00ed\n    }\n}", "gistURL": "https://gist.github.com/SwiftBeta/63925a2d4621ff0e9b77d3a0f0771446.js", "correct": "type_b", "explanation": "La palabra clave override en Swift permite a una subclase proporcionar una implementaci\u00f3n personalizada de un m\u00e9todo de la superclase.", "created_by": "SwiftBeta_"}, {"id": 8, "name": "Qu\u00e9 operador se utiliza para definir un valor predeterminado en caso de que el valor de una variable opcional sea nil?", "answers": [{"id": "type_a", "value": "??"}, {"id": "type_b", "value": "?:."}, {"id": "type_c", "value": "!.?"}, {"id": "type_d", "value": "&?"}], "code": "let optionalValue: Int? = nil\nlet defaultValue = 0\nlet result = optionalValue ?? defaultValue", "gistURL": "https://gist.github.com/SwiftBeta/e5edf55fbdb1eb41386559ac865f6be2.js", "correct": "type_a", "explanation": "El operador ?? se utiliza para definir un valor predeterminado en caso de que el valor de una variable opcional sea nil.", "created_by": "SwiftBeta_"}, {"id": 9, "name": "Cu\u00e1l de los siguientes tipos de datos en Swift es una colecci\u00f3n ordenada de elementos \u00fanicos?", "answers": [{"id": "type_a", "value": "Array"}, {"id": "type_b", "value": "Set"}, {"id": "type_c", "value": "Dictionary"}, {"id": "type_d", "value": "OrderedSet"}], "code": "", "gistURL": "", "correct": "type_b", "explanation": "Set es una colecci\u00f3n de elementos \u00fanicos, sin ning\u00fan orden espec\u00edfico, en Swift.", "created_by": "SwiftBeta_"}]}