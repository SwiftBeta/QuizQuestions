{"data": [{"id": 0, "name": "\u00bfCu\u00e1l de los siguientes es un m\u00e9todo correcto para definir una propiedad computada en Swift?", "answers": [{"id": "type_a", "value": "var area: Double { return width * height }"}, {"id": "type_b", "value": "var area: Double = { width * height }"}, {"id": "type_c", "value": "computed var area: Double { return width * height }"}, {"id": "type_d", "value": "var area: Double { get { return width * height } }"}], "code": "var width: Double = 10\nvar height: Double = 20", "gistURL": "https://gist.github.com/SwiftBeta/fe01bcf354b0d8476480e31af789b83a.js", "correct": "type_a", "explanation": "La propiedad computada debe ser declarada usando la sintaxis 'var' seguida por el nombre, tipo y el bloque de c\u00f3digo que devuelve el valor calculado.", "created_by": "SwiftBeta_"}, {"id": 1, "name": "\u00bfQu\u00e9 tipo de propiedad en Swift se usa para almacenar una referencia que es \u00fanica para la instancia de la clase?", "answers": [{"id": "type_a", "value": "lazy property"}, {"id": "type_b", "value": "weak property"}, {"id": "type_c", "value": "unowned property"}, {"id": "type_d", "value": "strong property"}], "code": "", "gistURL": "", "correct": "type_c", "explanation": "Las propiedades 'unowned' se utilizan para mantener una referencia no propietaria a una instancia \u00fanica de una clase, lo que evita ciclos de referencia (reference cycles) y mantiene una relaci\u00f3n de uno a uno.", "created_by": "SwiftBeta_"}, {"id": 2, "name": "\u00bfQu\u00e9 operador permite el encadenamiento seguro de propiedades opcionales en Swift?", "answers": [{"id": "type_a", "value": "!."}, {"id": "type_b", "value": "??."}, {"id": "type_c", "value": "?.<br/>"}, {"id": "type_d", "value": "&.&"}], "code": "", "gistURL": "", "correct": "type_c", "explanation": "El operador '?' permite un acceso seguro a propiedades opcionales, reduce la necesidad de usar condicionales 'if let' y 'guard' m\u00faltiples, y proporciona una forma m\u00e1s elegante de acceder a las propiedades opcionales.", "created_by": "SwiftBeta_"}, {"id": 3, "name": "\u00bfCu\u00e1l de las siguientes afirmaciones sobre los closures en Swift es correcta?", "answers": [{"id": "type_a", "value": "Los closures requieren siempre un nombre y una lista de par\u00e1metros."}, {"id": "type_b", "value": "Los closures no pueden capturar y almacenar referencias a las variables y constantes de su entorno."}, {"id": "type_c", "value": "Los closures pueden tener un contexto l\u00e9xico en su entorno."}, {"id": "type_d", "value": "Los closures no pueden ser asignados a variables o constantes."}], "code": "", "gistURL": "", "correct": "type_c", "explanation": "Los closures pueden tener un contexto l\u00e9xico en su entorno, lo que permite que puedan capturar y almacenar referencias a las variables y constantes definidas en su contexto.", "created_by": "SwiftBeta_"}, {"id": 4, "name": "\u00bfCu\u00e1l de las siguientes afirmaciones es verdadera acerca de 'ObservedObject' en SwiftUI?", "answers": [{"id": "type_a", "value": "Actualiza la vista cuando se modifican los datos."}, {"id": "type_b", "value": "Sirve como dep\u00f3sito temporal para objetos."}, {"id": "type_c", "value": "No es compatible con la actualizaci\u00f3n en tiempo real."}, {"id": "type_d", "value": "No puede ser utilizado con propiedades '@State'."}], "code": "", "gistURL": "", "correct": "type_a", "explanation": "'ObservedObject' es una propiedad que permite a SwiftUI actualizar la vista cuando los datos almacenados en una clase observada cambian, proporcionando la capacidad de actualizaci\u00f3n en tiempo real.", "created_by": "SwiftBeta_"}]}