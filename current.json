{"data": [{"id": 0, "name": "\u00bfCu\u00e1l es la forma correcta de marcar una propiedad como de solo lectura en Swift?", "answers": [{"id": "type_a", "value": "private(set) var property"}, {"id": "type_b", "value": "readonly var property"}, {"id": "type_c", "value": "private var property"}, {"id": "type_d", "value": "let property"}], "code": "class Example {\n    private(set) var property: Int\n}", "gistURL": "https://gist.github.com/SwiftBeta/ed3816f26422300b9690183b916ac411.js", "correct": "type_a", "explanation": "La opci\u00f3n correcta es private(set) var property. Esto permite que la propiedad se lea en cualquier lugar, pero solo se modifique dentro de la misma clase o estructura.", "created_by": "SwiftBeta_"}, {"id": 1, "name": "\u00bfCu\u00e1l es la forma correcta de declarar una propiedad computada en Swift?", "answers": [{"id": "type_a", "value": "var property { get }"}, {"id": "type_b", "value": "var property { return someExpression }"}, {"id": "type_c", "value": "var property -> someType { return someExpression }"}, {"id": "type_d", "value": "var property: someType { return someExpression }"}], "code": "class Example {\n    var baseValue: Int\n    var computedProperty: Int {\n        return baseValue * 2\n    }\n}", "gistURL": "https://gist.github.com/SwiftBeta/1167994f13fa7693f3f0240c1f81d376.js", "correct": "type_d", "explanation": "La opci\u00f3n correcta es var property: someType { return someExpression }. Declara el tipo de la propiedad y contiene una expresi\u00f3n que se ejecuta cuando se accede a ella.", "created_by": "SwiftBeta_"}, {"id": 2, "name": "\u00bfCu\u00e1l de las siguientes opciones NO es una palabra clave que representa un nivel de acceso en Swift?", "answers": [{"id": "type_a", "value": "public"}, {"id": "type_b", "value": "internal"}, {"id": "type_c", "value": "private"}, {"id": "type_d", "value": "local"}], "code": "", "gistURL": "", "correct": "type_d", "explanation": "La opci\u00f3n correcta es 'local', ya que no es un nivel de acceso en Swift. Los niveles de acceso en Swift son public, internal y private.", "created_by": "SwiftBeta_"}, {"id": 3, "name": "\u00bfC\u00f3mo se puede inicializar una matriz en Swift con un tama\u00f1o fijo y un valor predeterminado?", "answers": [{"id": "type_a", "value": "Array(repeating: value, count: size)"}, {"id": "type_b", "value": "Array(size, defaultValue: value)"}, {"id": "type_c", "value": "Array(length: size, initialValue: value)"}, {"id": "type_d", "value": "Array(size, value: value)"}], "code": "let fixedSizeArray = Array(repeating: 0, count: 10)", "gistURL": "https://gist.github.com/SwiftBeta/cd1b9e9c8f033f2c37edc9ef5f20c271.js", "correct": "type_a", "explanation": "La opci\u00f3n correcta es Array(repeating: value, count: size). Esta inicializaci\u00f3n crea una matriz de un tama\u00f1o espec\u00edfico y llena cada elemento con un valor predeterminado.", "created_by": "SwiftBeta_"}, {"id": 4, "name": "\u00bfCu\u00e1l de las siguientes opciones NO es una forma v\u00e1lida de desempaquetar un valor opcional en Swift?", "answers": [{"id": "type_a", "value": "Usar if let"}, {"id": "type_b", "value": "Usar guard let"}, {"id": "type_c", "value": "Usar force unwrap (!)"}, {"id": "type_d", "value": "Usar try catch"}], "code": "let optionalValue: Int? = 42\n\nif let value = optionalValue {}\n\nguard let value = optionalValue else { return }\n\nlet value = optionalValue!", "gistURL": "https://gist.github.com/SwiftBeta/1ee62d4e1d717398291583cdef8af4ea.js", "correct": "type_d", "explanation": "La opci\u00f3n correcta es 'Usar try catch'. try-catch se utiliza para manejar errores en Swift, no para desempaquetar valores opcionales. if let, guard let y force unwrap son formas v\u00e1lidas de desempaquetar opcionales.", "created_by": "SwiftBeta_"}, {"id": 5, "name": "\u00bfQu\u00e9 hace la palabra clave 'defer' en Swift?", "answers": [{"id": "type_a", "value": "Retrasa la ejecuci\u00f3n de un bloque de c\u00f3digo hasta que el programa sale del alcance actual"}, {"id": "type_b", "value": "Crea un bloque de c\u00f3digo as\u00edncrono que se ejecuta en segundo plano"}, {"id": "type_c", "value": "Indica que un m\u00e9todo debe ser implementado por una subclase"}, {"id": "type_d", "value": "Marca un m\u00e9todo como obsoleto"}], "code": "func example() {\n    defer {\n        print(\"This will be executed last\")\n    }\n    print(\"This will be executed first\")\n}", "gistURL": "https://gist.github.com/SwiftBeta/3c5514f714ce93192751919912fe814b.js", "correct": "type_a", "explanation": "La opci\u00f3n correcta es 'Retrasa la ejecuci\u00f3n de un bloque de c\u00f3digo hasta que el programa sale del alcance actual'. La palabra clave defer se utiliza para garantizar que cierto c\u00f3digo se ejecute antes de que la funci\u00f3n o el bloque de c\u00f3digo actual termine.", "created_by": "SwiftBeta_"}, {"id": 6, "name": "\u00bfCu\u00e1l es la salida de este c\u00f3digo en Swift?", "answers": [{"id": "type_a", "value": "5"}, {"id": "type_b", "value": "0"}, {"id": "type_c", "value": "Nada"}, {"id": "type_d", "value": "Error de compilaci\u00f3n"}], "code": "func add(_ a: Int, _ b: Int) -> Int {\n    return a + b\n}\n\nlet result = add(2, 3)\nprint(result)", "gistURL": "https://gist.github.com/SwiftBeta/5de22cf1fbe1c4e9adff89df32f6424e.js", "correct": "type_a", "explanation": "La opci\u00f3n correcta es 5. La funci\u00f3n add() toma dos n\u00fameros enteros como par\u00e1metros y devuelve la suma de ellos. En este caso, se llama con los valores 2 y 3, por lo que el resultado es 5.", "created_by": "SwiftBeta_"}, {"id": 7, "name": "\u00bfCu\u00e1l de los siguientes NO es un tipo de colecci\u00f3n en Swift?", "answers": [{"id": "type_a", "value": "Array"}, {"id": "type_b", "value": "Dictionary"}, {"id": "type_c", "value": "Set"}, {"id": "type_d", "value": "Queue"}], "code": "", "gistURL": "", "correct": "type_d", "explanation": "La opci\u00f3n correcta es Queue. Swift no tiene un tipo de colecci\u00f3n incorporado llamado Queue. Los tipos de colecciones en Swift son Array, Dictionary y Set.", "created_by": "SwiftBeta_"}, {"id": 8, "name": "\u00bfCu\u00e1l es la forma correcta de declarar una extensi\u00f3n en Swift?", "answers": [{"id": "type_a", "value": "extension TypeName"}, {"id": "type_b", "value": "extend TypeName"}, {"id": "type_c", "value": "class TypeName: SuperType"}, {"id": "type_d", "value": "interface TypeName"}], "code": "struct Example {\n    var value: Int\n}\n\nextension Example {\n    var doubleValue: Int {\n        return value * 2\n    }\n}", "gistURL": "https://gist.github.com/SwiftBeta/1734f86ff53b8d2588521383ebd7c2f8.js", "correct": "type_a", "explanation": "La opci\u00f3n correcta es 'extension TypeName'. Las extensiones en Swift se declaran usando la palabra clave 'extension' seguida del nombre del tipo que se va a extender.", "created_by": "SwiftBeta_"}, {"id": 9, "name": "\u00bfCu\u00e1l de las siguientes opciones no es una forma v\u00e1lida de declarar una variable en SwiftUI?", "answers": [{"id": "type_a", "value": "@State private var variable"}, {"id": "type_b", "value": "@Binding var variable"}, {"id": "type_c", "value": "@ObservedObject var variable"}, {"id": "type_d", "value": "@Variable var variable"}], "code": "import SwiftUI\n\nstruct ContentView: View {\n    @State private var stateVariable: Int\n    @Binding var bindingVariable: Int\n    @ObservedObject var observedObjectVariable: SomeObservableObject\n}", "gistURL": "https://gist.github.com/SwiftBeta/5d825dfca578ca15c2b9f11c1e25d04f.js", "correct": "type_d", "explanation": "La opci\u00f3n correcta es '@Variable var variable'. No existe una propiedad wrapper llamada @Variable en SwiftUI. Las otras opciones son wrappers de propiedad v\u00e1lidos en SwiftUI.", "created_by": "SwiftBeta_"}]}