{"data": [{"id": 0, "name": "\u00bfCu\u00e1l es la declaraci\u00f3n correcta de una clase de Singleton en Swift?", "answers": [{"id": "type_a", "value": "class Singleton { static let sharedInstance = Singleton() }"}, {"id": "type_b", "value": "class Singleton { static var sharedInstance = Singleton() }"}, {"id": "type_c", "value": "class Singleton { let sharedInstance = Singleton() }"}, {"id": "type_d", "value": "struct Singleton { static let sharedInstance = Singleton() }"}], "code": "class Singleton {}", "gistURL": "https://gist.github.com/SwiftBeta/87a814c9ded62700880e2cbfa45bf2ad.js", "correct": "type_a", "explanation": "La declaraci\u00f3n correcta de una clase de Singleton en Swift es utilizando 'static let' para crear una instancia \u00fanica y compartida de la clase.", "created_by": "SwiftBeta_"}, {"id": 1, "name": "\u00bfQu\u00e9 ocurre al llamar a la funci\u00f3n 'sum' en el siguiente c\u00f3digo?", "answers": [{"id": "type_a", "value": "La funci\u00f3n retorna 0"}, {"id": "type_b", "value": "La funci\u00f3n retorna 3"}, {"id": "type_c", "value": "La funci\u00f3n causa un error de compilaci\u00f3n"}, {"id": "type_d", "value": "La funci\u00f3n causa un error en tiempo de ejecuci\u00f3n"}], "code": "func sum(_ a: Int, _ b: Int = 0) -> Int { return a + b } let result = sum(3)", "gistURL": "https://gist.github.com/SwiftBeta/d319c15458b7d912016c3b8ff71363dc.js", "correct": "type_b", "explanation": "La funci\u00f3n sum tiene un par\u00e1metro con un valor predeterminado de 0, por lo que al llamar a 'sum(3)', el valor de b es 0 y la funci\u00f3n retorna 3.", "created_by": "SwiftBeta_"}, {"id": 2, "name": "\u00bfCu\u00e1l es la sintaxis correcta para a\u00f1adir un observador de propiedad en Swift?", "answers": [{"id": "type_a", "value": "var property: Int { didSet { ... } }"}, {"id": "type_b", "value": "var property: Int { willSet { ... } }"}, {"id": "type_c", "value": "var property: Int { beforeSet { ... } }"}, {"id": "type_d", "value": "var property: Int { afterSet { ... } }"}], "code": "", "gistURL": "", "correct": "type_a", "explanation": "En Swift, un observador de propiedad se define utilizando '{ didSet { ... } }' o '{ willSet { ... } }'.", "created_by": "SwiftBeta_"}, {"id": 3, "name": "\u00bfC\u00f3mo se define un protocolo con propiedades y m\u00e9todos en Swift?", "answers": [{"id": "type_a", "value": "protocol MyProtocol { var property: Int { get set } func myMethod() }"}, {"id": "type_b", "value": "protocol MyProtocol { property: Int; func myMethod() }"}, {"id": "type_c", "value": "protocol MyProtocol { var property: Int; func myMethod() }"}, {"id": "type_d", "value": "protocol MyProtocol { var property: Int; myMethod() }"}], "code": "protocol MyProtocol {}", "gistURL": "https://gist.github.com/SwiftBeta/9397206e2940d573c76971e9b420bc2a.js", "correct": "type_a", "explanation": "Un protocolo en Swift se define utilizando la palabra clave 'protocol', las propiedades con una declaraci\u00f3n de acceso 'get' y 'set', y los m\u00e9todos con la palabra clave 'func'.", "created_by": "SwiftBeta_"}, {"id": 4, "name": "\u00bfQu\u00e9 es un 'result builder' en SwiftUI?", "answers": [{"id": "type_a", "value": "Un generador de secuencias de c\u00f3digo"}, {"id": "type_b", "value": "Un generador de vistas anidadas"}, {"id": "type_c", "value": "Un generador de objetos JSON"}, {"id": "type_d", "value": "Un generador de interfaces de usuario"}], "code": "@resultBuilder struct MyBuilder { ... }", "gistURL": "https://gist.github.com/SwiftBeta/68fa5e7458fc203112a2aa6e02548dc7.js", "correct": "type_b", "explanation": "Un 'result builder' en SwiftUI es un generador de vistas anidadas que permite construir vistas de una manera m\u00e1s declarativa y menos verbosa.", "created_by": "SwiftBeta_"}, {"id": 5, "name": "\u00bfCu\u00e1l es la salida del siguiente c\u00f3digo en Swift?", "answers": [{"id": "type_a", "value": "true"}, {"id": "type_b", "value": "false"}, {"id": "type_c", "value": "null"}, {"id": "type_d", "value": "Ninguna de las anteriores"}], "code": "class A { static func ==(lhs: A, rhs: A) -> Bool { return true } } let a = A() let b = A() print(a == b)", "gistURL": "https://gist.github.com/SwiftBeta/b5da36d13b5ae94e36c1aad0d7aeeb7f.js", "correct": "type_a", "explanation": "El operador '==' est\u00e1 sobrecargado en la clase A para siempre retornar 'true', por lo que 'a == b' imprimir\u00e1 'true'.", "created_by": "SwiftBeta_"}, {"id": 6, "name": "\u00bfCu\u00e1l es la sintaxis correcta para declarar una enumeraci\u00f3n con valores asociados en Swift?", "answers": [{"id": "type_a", "value": "enum MyEnum { case A(Int) case B(String) }"}, {"id": "type_b", "value": "enum MyEnum { case A = Int case B = String }"}, {"id": "type_c", "value": "enum MyEnum { case A(Int), B(String) }"}, {"id": "type_d", "value": "enum MyEnum { case A: Int case B: String }"}], "code": "enum MyEnum {}", "gistURL": "https://gist.github.com/SwiftBeta/871487d0fd6953e1cfbab208f6bebc89.js", "correct": "type_a", "explanation": "Una enumeraci\u00f3n con valores asociados en Swift se declara utilizando la sintaxis 'enum MyEnum { case A(ValueType) case B(ValueType) }'.", "created_by": "SwiftBeta_"}, {"id": 7, "name": "\u00bfQu\u00e9 hace la funci\u00f3n 'compactMap' en Swift?", "answers": [{"id": "type_a", "value": "Filtra y transforma los elementos de un Array"}, {"id": "type_b", "value": "Combina los elementos de dos Arrays"}, {"id": "type_c", "value": "Clona un Array"}, {"id": "type_d", "value": "Ordena los elementos de un Array"}], "code": "let numbers = [1, 2, nil, 4, 5, nil] let compactedNumbers = numbers.compactMap { $0 }", "gistURL": "https://gist.github.com/SwiftBeta/90a1be78e3ef6530fbb03e1d4bf69dce.js", "correct": "type_a", "explanation": "La funci\u00f3n 'compactMap' en Swift filtra y transforma los elementos de un Array, eliminando los elementos 'nil' y devolviendo un nuevo Array con los elementos no nulos.", "created_by": "SwiftBeta_"}, {"id": 8, "name": "\u00bfQu\u00e9 permite la palabra clave 'as?' en Swift?", "answers": [{"id": "type_a", "value": "Casting seguro"}, {"id": "type_b", "value": "Casting forzado"}, {"id": "type_c", "value": "Comprobaci\u00f3n de tipos"}, {"id": "type_d", "value": "Creaci\u00f3n de alias de tipos"}], "code": "let value: Any = 42 let intValue = value as? Int", "gistURL": "https://gist.github.com/SwiftBeta/450aecaea20bd7f9e9b0fd8d82f3c684.js", "correct": "type_a", "explanation": "La palabra clave 'as?' en Swift permite realizar un casting seguro de un tipo a otro. Si el casting no es posible, devuelve 'nil'.", "created_by": "SwiftBeta_"}, {"id": 9, "name": "\u00bfCu\u00e1l es la diferencia entre 'unowned' y 'weak' en Swift?", "answers": [{"id": "type_a", "value": "'unowned' puede ser 'nil', mientras que 'weak' no puede"}, {"id": "type_b", "value": "'unowned' no puede ser 'nil', mientras que 'weak' puede"}, {"id": "type_c", "value": "'unowned' es una referencia fuerte y 'weak' es una referencia d\u00e9bil"}, {"id": "type_d", "value": "'unowned' es una referencia d\u00e9bil y 'weak' es una referencia fuerte"}], "code": "class A { weak var property: B? } class B { unowned var property: A }", "gistURL": "https://gist.github.com/SwiftBeta/30663a4df3b7ca32650613e6cecb1fcc.js", "correct": "type_b", "explanation": "La diferencia entre 'unowned' y 'weak' en Swift es que 'unowned' no puede ser 'nil' y siempre se espera que tenga un valor, mientras que 'weak' puede ser 'nil' y se utiliza para evitar referencias fuertes y retenci\u00f3n de ciclos.", "created_by": "SwiftBeta_"}]}