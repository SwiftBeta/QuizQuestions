{"data": [{"id": 0, "name": "\u00bfQu\u00e9 m\u00e9todo se utiliza para ejecutar un bloque de c\u00f3digo en un DispatchQueue despu\u00e9s de un retardo espec\u00edfico?", "answers": [{"id": "type_a", "value": "asyncTrigger(after: DispatchTime, block: @escaping () -> Void)"}, {"id": "type_b", "value": "asyncAfter(deadline: DispatchTime, execute: @escaping () -> Void)"}, {"id": "type_c", "value": "triggerAfter(delay: TimeInterval, block: @escaping () -> Void)"}, {"id": "type_d", "value": "delayTrigger(deadline: DispatchTime, execute: @escaping () -> Void)"}], "code": "DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) { print(\"Executed after 3 seconds\") }", "gistURL": "https://gist.github.com/SwiftBeta/c823adbd7df803427fa36c436cef89b1.js", "correct": "type_b", "explanation": "Se utiliza el m\u00e9todo 'asyncAfter(deadline:execute:)' para ejecutar un bloque de c\u00f3digo en un DispatchQueue despu\u00e9s de un retardo espec\u00edfico.", "created_by": "SwiftBeta_"}, {"id": 1, "name": "\u00bfCu\u00e1l de las siguientes opciones implementa correctamente el protocolo Identifiable en una estructura?", "answers": [{"id": "type_a", "value": "protocol Identifiable {\n    var id: Int }\nstruct Person: Identifiable {\n    var id: Int\n}"}, {"id": "type_b", "value": "protocol Identifiable {\n    var id: UUID }\nstruct Person: Identifiable {\n    var id: UInt64\n}"}, {"id": "type_c", "value": "struct Person: Identifiable {\n    var id: Int\n}"}, {"id": "type_d", "value": "struct Person: Identifiable {\n    var id: UUID\n}"}], "code": "", "gistURL": "", "correct": "type_d", "explanation": "Al hacer que la estructura confirme el protocolo Identifiable, es necesario proporcionar una propiedad id con un tipo de dato que cumpla con las condiciones del protocolo. En este caso, la propiedad id es de tipo UUID.", "created_by": "SwiftBeta_"}, {"id": 2, "name": "\u00bfQu\u00e9 opci\u00f3n muestra el uso correcto del m\u00e9todo flatMap en un Array?", "answers": [{"id": "type_a", "value": "[1,2,3,4].flatMap { $0 * 2 }"}, {"id": "type_b", "value": "[1,2,3,4].flatMap { Array(0..<$0) }"}, {"id": "type_c", "value": "[1,2,3,4].map { Array(0..<$0) }"}, {"id": "type_d", "value": "flatMap([1,2,3,4], transform: { Array(0..<$0) })"}], "code": "let numbers = [1, 2, 3, 4]\nlet result = numbers.flatMap { Array(0..<$0) }\n// Result: [0, 0, 1, 0, 1, 2]", "gistURL": "https://gist.github.com/SwiftBeta/f2846135d87ab30ddee3cc0fe08323fa.js", "correct": "type_b", "explanation": "flatMap se utiliza para aplicar una transformaci\u00f3n a los elementos de un Array y aplanar el resultado en un \u00fanico Array. La opci\u00f3n B utiliza flatMap correctamente.", "created_by": "SwiftBeta_"}, {"id": 3, "name": "\u00bfCu\u00e1l de las siguientes opciones presenta la implementaci\u00f3n correcta para convertir una URL en una UIImage?", "answers": [{"id": "type_a", "value": "let image = UIImage(contentsOfFile: url)"}, {"id": "type_b", "value": "let image = UIImage(named: url)"}, {"id": "type_c", "value": "let image = UIImage(contentsOfFile: url.absoluteString)"}, {"id": "type_d", "value": "let image = UIImage(data: try Data(contentsOf: url))"}], "code": "if let url = URL(string: \"https://example.com/image.png\") {\n    let imageData = try? Data(contentsOf: url)\n    if let data = imageData {\n        let image = UIImage(data: data)\n    }\n}", "gistURL": "https://gist.github.com/SwiftBeta/b65498ca9c57f677fbf52b0e630b4e0d.js", "correct": "type_d", "explanation": "Primero se crea un objeto Data a partir de la URL y luego se crea la imagen UIImage utilizando el inicializador 'init(data:)'.", "created_by": "SwiftBeta_"}, {"id": 4, "name": "\u00bfQu\u00e9 modificador de acceso se utiliza cuando se desea restringir el uso de un miembro solo al archivo de origen?", "answers": [{"id": "type_a", "value": "private"}, {"id": "type_b", "value": "fileprivate"}, {"id": "type_c", "value": "public"}, {"id": "type_d", "value": "internal"}], "code": "class MyClass {\n    fileprivate func myRestrictedFunction() {\n        // Accessible only within the same source file.\n    }\n}", "gistURL": "https://gist.github.com/SwiftBeta/ddb9bd7cd368cdeca2c28d75bd9357cc.js", "correct": "type_b", "explanation": "El modificador de acceso 'fileprivate' permite el acceso solo dentro del mismo archivo de origen.", "created_by": "SwiftBeta_"}, {"id": 5, "name": "\u00bfCu\u00e1l de las siguientes opciones describe correctamente la diferencia entre ObservedObject y StateObject en SwiftUI?", "answers": [{"id": "type_a", "value": "ObservedObject se utiliza para objetos de clase, StateObject se utiliza para objetos de estructura"}, {"id": "type_b", "value": "StateObject se utiliza para objetos de clase, ObservedObject se utiliza para objetos de estructura"}, {"id": "type_c", "value": "StateObject crea y posee ese objeto a lo largo de la vida de la vista, ObservedObject no crea ni posee el objeto"}, {"id": "type_d", "value": "ObservedObject crea y posee ese objeto a lo largo de la vida de la vista, StateObject no crea ni posee el objeto"}], "code": "", "gistURL": "", "correct": "type_c", "explanation": "StateObject crea y posee el objeto durante toda la vida de la vista en la que se instancia, mientras que ObservedObject solo observa el objeto sin crearlo ni poseerlo.", "created_by": "SwiftBeta_"}, {"id": 6, "name": "\u00bfQu\u00e9 palabra clave se utiliza para denotar un bloque de c\u00f3digo que puede lanzar un error en Swift?", "answers": [{"id": "type_a", "value": "try"}, {"id": "type_b", "value": "catch"}, {"id": "type_c", "value": "throw"}, {"id": "type_d", "value": "throws"}], "code": "func canThrowErrors() throws {\n    // This function can throw errors\n}\n\nfunc example() {\n    do {\n        try canThrowErrors()\n        print(\"No errors\")\n    } catch {\n        print(\"An error occurred\")\n    }\n}", "gistURL": "https://gist.github.com/SwiftBeta/17dfbd25f8c414c9fbdc7e8f5d030fc9.js", "correct": "type_a", "explanation": "La palabra clave 'try' se utiliza para denotar que un bloque de c\u00f3digo puede lanzar un error y debe ser manejado en un bloque 'do-catch'.", "created_by": "SwiftBeta_"}, {"id": 7, "name": "\u00bfCu\u00e1l es el m\u00e9todo SwiftUI que actualiza la vista cuando se produce un cambio en sus dependencias?", "answers": [{"id": "type_a", "value": "redraw()"}, {"id": "type_b", "value": "refresh()"}, {"id": "type_c", "value": "update()"}, {"id": "type_d", "value": "body"}], "code": "", "gistURL": "", "correct": "type_d", "explanation": "En SwiftUI, la propiedad 'body' de una vista es responsable de actualizar la vista cuando se producen cambios en sus dependencias.", "created_by": "SwiftBeta_"}, {"id": 8, "name": "\u00bfQu\u00e9 componente se utiliza para definir un punto de entrada principal en la biblioteca Combine?", "answers": [{"id": "type_a", "value": "CombinePublisher"}, {"id": "type_b", "value": "CombineSubject"}, {"id": "type_c", "value": "CombineStream"}, {"id": "type_d", "value": "CombinePassthroughSubject"}], "code": "", "gistURL": "", "correct": "type_d", "explanation": "CombinePassthroughSubject es un componente de la biblioteca Combine que define un punto de entrada para transmitir datos a los componentes suscritos.", "created_by": "SwiftBeta_"}, {"id": 9, "name": "\u00bfCu\u00e1l es la novedad de Xcode 12?", "answers": [{"id": "type_a", "value": "Compatibilidad con Swift 5.3"}, {"id": "type_b", "value": "Compatibilidad con iOS 14 y macOS Big Sur"}, {"id": "type_c", "value": "Refactorizaci\u00f3n de c\u00f3digo"}, {"id": "type_d", "value": "Integraci\u00f3n con Github"}], "code": "", "gistURL": "", "correct": "type_b", "explanation": "Xcode 12 es compatible con iOS 14 y macOS Big Sur, y trae caracter\u00edsticas nuevas como la compatibilidad con el dise\u00f1o de aplicaciones multiplataforma y la incorporaci\u00f3n de SwiftUI.", "created_by": "SwiftBeta_"}]}